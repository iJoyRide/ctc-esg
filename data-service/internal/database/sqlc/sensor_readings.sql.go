// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sensor_readings.sql

package db

import (
	"context"
	"time"
)

const checkSensorIdExists = `-- name: CheckSensorIdExists :one
SELECT EXISTS (
    SELECT 1 
    FROM sensor_readings 
    WHERE sensor_id = $1
)
`

func (q *Queries) CheckSensorIdExists(ctx context.Context, sensorID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSensorIdExists, sensorID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getLatestReadingsBySensorID = `-- name: GetLatestReadingsBySensorID :many
SELECT DISTINCT ON (sensor)
    sensor,
    value,
    timestamp
FROM sensor_readings
WHERE chiller_id = $1
ORDER BY sensor, timestamp DESC
`

type GetLatestReadingsBySensorIDRow struct {
	Sensor    string
	Value     float64
	Timestamp time.Time
}

func (q *Queries) GetLatestReadingsBySensorID(ctx context.Context, chillerID string) ([]GetLatestReadingsBySensorIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestReadingsBySensorID, chillerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestReadingsBySensorIDRow
	for rows.Next() {
		var i GetLatestReadingsBySensorIDRow
		if err := rows.Scan(&i.Sensor, &i.Value, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadingsByBucket = `-- name: GetReadingsByBucket :many
SELECT 
    time_bucket($1::text::interval, timestamp)::timestamptz AS bucket,
    AVG(value)::float AS avg_value
FROM sensor_readings
WHERE sensor_id = $2 
  AND timestamp >= $3 
  AND timestamp <  $4
GROUP BY bucket
ORDER BY bucket ASC
`

type GetReadingsByBucketParams struct {
	BucketWidth string
	SensorID    string
	StartTime   time.Time
	EndTime     time.Time
}

type GetReadingsByBucketRow struct {
	Bucket   time.Time
	AvgValue float64
}

func (q *Queries) GetReadingsByBucket(ctx context.Context, arg GetReadingsByBucketParams) ([]GetReadingsByBucketRow, error) {
	rows, err := q.db.QueryContext(ctx, getReadingsByBucket,
		arg.BucketWidth,
		arg.SensorID,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReadingsByBucketRow
	for rows.Next() {
		var i GetReadingsByBucketRow
		if err := rows.Scan(&i.Bucket, &i.AvgValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSensorReading = `-- name: InsertSensorReading :exec
INSERT INTO sensor_readings (timestamp, sensor, sensor_id, chiller_id, value)
VALUES ($1, $2, $3, $4, $5)
`

type InsertSensorReadingParams struct {
	Timestamp time.Time
	Sensor    string
	SensorID  string
	ChillerID string
	Value     float64
}

func (q *Queries) InsertSensorReading(ctx context.Context, arg InsertSensorReadingParams) error {
	_, err := q.db.ExecContext(ctx, insertSensorReading,
		arg.Timestamp,
		arg.Sensor,
		arg.SensorID,
		arg.ChillerID,
		arg.Value,
	)
	return err
}
